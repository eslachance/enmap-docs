[[{"i":"#","p":["Enmap, the super simple database wrapper with over a million downloads to date. Wrapping around better-sqlite3 with its warm embrace, it's the easiest way to save data in node for your first project!"]},{"l":"What is Enmap?","p":["Enmap stands for \"Enhanced Map\", and is a data structure based on the native JavaScript Map() structure with additional helper methods from the native Array() structure. Enmap also offers persistence, which means it will automatically save everything to save to it in a database, in the background, without any additional code or delays.","Enmap requires filesystem access. It DOES NOT WORK on Heroku, or other such systems that do not allow you to save data directly to disk.","It should also not be used on Repl.it where the data cannot be hidden (and will be public) or on * Glitch* which has been known to break Enmap's data persistence and lose data."]},{"l":"Why Enmap?","p":["While there are other better-known systems that offer some features of Enmap, especially caching in memory, Enmap is targeted specifically to newer users of JavaScript that might not want to deal with complicated systems or database queries."]},{"l":"Advantage/Disadvantage","p":["Here are some advantages of using Enmap:","Simple to Install: Enmap itself only requires a simple npm install command to install and use, and a single line to initialize. See Installation for details.","Simple to Use: Basic Enmap usage can be completely done with 1-2 lines of initialization, and 3 commands, set(), get() and delete().","Very Fast: Since Enmap resides in memory, accessing its data is blazing fast (as fast as Map() is). Even with persistence, Enmap still accesses data from memory so you get it almost instantly.","Some disadvantages, compared to using a database connection directly:","More memory use: Since Enmap resides in memory and (by default) all its data is loaded when it starts, your entire data resides in RAM. When using a large amount of data on a low-end computer or VPS, this might be an issue for some users.","Limited power: You can have multiple Enmap \"tables\" loaded in your app, but they do not and cannot have relationships between them. Basically, one Enmap value can't refer to another value in another Enmap. This is something databases can be very good at, but due to the simplistic nature of Enmap, it's not possible here.","Lack of scalability: Enmap is great for small apps that require a simple key/value storage. However, a scalable app spread over multiple processes, shards, or clusters, will be severely limited by Enmap as it cannot update itself from the database on change - one process would not be aware of another process' changes."]}],[{"i":"#","p":["To install Enmap, please read these instructions very carefully, every word is important!"]},{"l":"Enmap Installation","p":["Enmap is a wrapper around better-sqlite3, which requires to be built directly on your system. As such, you need to install pre-requisites first. Please follow these instructions to the letter. If it's not written here, you probably shouldn't do it unless you know why you're doing it."]},{"l":"Pre-Requisites","p":["SQLite modules usually only successfully work on LTS versions of node which are even-numbered. This means it will work on node 18, 20, 22 but will most likely not work on 17, 19, 21. Make sure you have the right version, check this with node -v.","How to install the pre-requisites depends on your operating system, so see below for instructions:","On Windows, two things are required to install better-sqlite3. Python, and the Visual Studio C++ Build Tools. They are required for any module that is built on the system, which includes sqlite.","The Easy Way: When installing NodeJS, in the \"Tools for native modules\", make sure to check the option \"Automatically install the necessary tools\". This will install the required dependencies.","The slightly harder way: If you've already installed nodejs and don't wish to reinstall it, you can install the tools using choco. Once choco is installed, simply run the following command, under an administrative command prompt or powershell:","If you get an error here READ THIS: It's very important that this be run in the administrative prompt, and not a regular one. Run as admin.","Once the build tools are installed (this might take quite some time, depending on your internet connection), close all open command prompts, powershell windows, VSCode, and editors with a built-in console/prompt. Otherwise, the next command will not work.","On Linux, the pre-requisites are much simpler in a way. A lot of modern systems (such as Ubuntu, since 16.04) already come with python pre-installed. For some other systems, you might have to fiddle with it to install python (2 or 3, whichever is easiest). Google will be your friend as is customary with Linux.","As for the C++ build tools, that's installed using the simple command: sudo apt-get install build-essential for most debian-based systems. For others, look towards your package manager and specificall \"GCC build tools\".","As of writing this page, MacOS versions seem to all come pre-built with Python on the system. You will, however, need the C++ build tools.","Install XCode","Once XCode is installed, go to Preferences, Downloads, and install the Command Line Tools.","Once installed, you're ready to continue."]},{"l":"Installing Enmap","p":["Once those pre-requisites are installed and you've closed all open command prompts, open a new, normal(not-admin) command prompt or terminal in your project, then install Enmap using the following command:","This will take a few minutes, as it needs to build better-sqlite3 from source code, and then install enmap itself. Note that \"a few minutes\" can be 1 or 30 minutes, it really depends on your hardware and configuration.","If you get any errors, please see the Troubleshooting Guide. If the guide doesn't help, join the Discord (link at the top of this page)."]}],[{"i":"#","p":["\"Anything that can go wrong will go wrong\" - Murphy's Law"]},{"l":"Troubleshooting Guide","p":["Please make sure to read the install page VERY CAREFULLY! This should solve all the issues you face. If not carry on, but don't say we didn't tell you."]},{"l":"It's Taking Suuuuuuuuuuuuuuuuuper Long to Install! Whats up with that?","p":["Your computer has to install some programs and then build everything from source. This is going to take a while depending on your computer speed. Patience is key. We can't speed it up for you. It may look like its frozen but it is not.","Some tips: Make sure you are doing this install on a fast hard drive (ideally SSD, but HDD will work fine) and not on a USB Key or removable media."]},{"l":"command failed downloading python or build tools","p":["Please restart this script in an administrative Powershel! means you did not read the install page correctly."]},{"l":"MSB3428: Could not load the Visual C++ component \"VCBuild.exe\"","p":["Looks like someone hasn't follows the installation instructions correctly...","(are you sensing there's a theme yet in this troubleshooting guide?)"]},{"l":"My Question Isn't Answered Here!","p":["Please make sure you read the install page first. If you can't find what your looking for you can join the discord here."]}],[{"i":"#","p":["This guide assists in migrating your data from Enmap 3 using Providers, to the latest version of enmap."]},{"l":"Migrating data from Enmap 3","p":["You do not need this page if you're new to Enmap or if you're starting a new project!","Upgrading to enmap v4 requires a little bit of migration, as Enmap 4 changed the internal method by which data is stored, slightly. To use this migration:","Make a copy of your current app in a new folder.","Create a new folder \"on the same level\" as your bot. Name it something like \"migrate\"","You should now have 3 folders. Something like mybots/coolbot, mybots/coolbot-copy, mybots/migrate/","In the migrate folder, run npm i enmap@3.1.4 enmap-sqlite@latest, as well as whatever source provider you need if it's not sqlite (in my example, npm i enmap-mongo@latest","You should now have something like the following image.","In the migrate folder, create an index.js and use the following script for migration. Note that it's an example, change the provider option to fit what you're actually using.","Very important: the \"target\" must be enmap-sqlite. Enmap v4 only supports an sqlite-backend.","From the migrate folder, run node index.js, which should correctly migrate your data."]},{"l":"Simpler migration from enmap-sqlite","p":["If you're using enmap-sqlite already, you don't really need to do the entire thing above. Adding a single file called migrate.js to your project folder, then running it with node migrate.js will convert the format and then all you need is to modify the code for Enmap 4. Still, I recommend backing up your bot first. Just in case."]},{"l":"Code Changes","p":["There is very little you need to change when moving to Enmap 4. The only changes that are required after migrating is the initialization of your Enmap which is now simpler.","If using Enmap.multi(), the change is just as simple:","The rest of your code (all interactions with Enmap) can remain the same - there should be no need to edit any of it."]},{"l":"Installing V4","p":["Once your data is migrating and the code is changed, you can go ahead and install enmap version 4 through npm i enmap@latest in your \"new\" bot folder (the target of the migration). This will take a few minutes (it needs to rebuild sqlite) and output that 4.0.x is now installed. Start the bot, and it should be working! If it doesn't, join the support server and we'll help you out _."]}],[{"l":"Upgrading Enmap to Version 6","p":["Version 6 of Enmap is a complete re-write, even though most of the API remains identical, and the data can easily be transfered.","Please pay attention to all the changes on this page :)"]},{"l":"Migration Method","p":["BEFORE YOU UPGRADE VERSION, you will need to use enmap.export() on Enmap 5, to have a functional backup.","I strongly advise copying your ./data directory... just in case this breaks ;)","Here's a quick and dirty script:","You will need to do this for every separate enmap (every \"name\") you have, individually, with separate export files!","Once exporting is done, you can npm i enmap@latest to get version 6.X. After this, the import needs to be done, as such:","Marginally tested, but should work fine for any and all data."]},{"l":"Move to ESM","p":["The first major change is the move to ECMAScript Modules, or ESM, which some erroneously call \"ES6 modules\". This change unfortunately not only affects the code related to Enmap but also means if you want to keep using it, you'll have to move to ESM too along with the rest of us. Gone is CJS, here comes ESM!","ESM has been around for a long time, it matches the module format used in other javascript engines (such as browsers) and it used by the majority of builder tools. If you're using Typescript or doing web frameworks, chances are you're using ESM already. And if you're still on CJS, well, going to ESM is important in your JavaScript developer journey anyways.","So what does this mean? It means modifying all your imports and exports, starting with Enmap:","Is that it? Yes, that's it... for my module. Now you have to do this for the rest of your code. Here's a bit of a guide for you."]},{"l":"Removal of the Caching","p":["Caching has been around since Enmap v1, for the simple reason that enmap used wrap around callback-based and promise-based database modules. In order to provide a synchronous interface to you, the user, the use of caching to update and read the database in the background. That hasn't been the case since Enmap 4 where I stripped out the providers and locked it to better-sqlite3, the only synchronous database module that exists for an actual database connection. That means I didn't need the cache anymore, but I kept it for performance reasons.","For more details and justifications, see \"Why Remove Cache?\".","This means the following Enmap features are obsolete and have been stripped out from V6, hopefully never to be added again.","enmap.fetch and enmap.fetchEverything: were used to query the database and put the data in cache.","enmap.evict: used to remove from cache.","enmap.array and enmap.keyArray: used to list values and keys from cache only.","enmap.indexes: used to get a list of keys in the database (not the cache).","options.fetchAll: determines whether to cache the entire database on load.","options.cloneLevel: was a workaround to objects provided by the user affecting objects in the cache.","options.polling and options.pollingInterval: used to update the cache on an interval, useful to sync many processes.","options.autoFetch: used to fetch values automatically when using enmap.get()","So all the above just don't exist anymore. However, they will return in Enmap 6.1 with optional controllable caching."]},{"l":"Removal of duplicate concerns","p":["Enmap used to essentially extend two different structures: the Map(), and the Array(), javascript structures. With the removal of the cache, the Map()... well... I guess at this point Enmap's name is historical because I'm not extending a Map anymore! However, the extension of Map() for cache and Array for feature meant there was a lot of duplication in the methods. Enmap V6 clears out any method that could be achieved with another method. I have made every possible effort not to lose power in Enmap, so if you find that something I removed was stupid, please feel free to make the case for it on our Discord server.","enmap.keys(), enmap.values() and enmap.entries() can be used to get only keys, only values, or both, in arrays. This will pull the entire database's worth of data, but that's what you were expecting, so it's fine, isn't it? As such, enmap.array() and enmap.keyArray() become obsolete and have been removed.","enmap.indexes also isn't useful anymore and was the \"uncached\" version of enmap.keys, so it's removed.","enmap.count and enmap.size have always been a bit confusing, especially since arrays have a length... so I've decided to just call it enmap.length. To maintain backwards compatibility, though, enmap.size will remain as an alias.","enmap.filter() and enmap.filterArray() were always a bit confusing to me. The idea of \"returning an Enmap\" from Enmap itself was always weird and I will no longer be doing that - that means that enmap.filter() will not simply return an array, and that's it. Also, it returns an array of values, and does not concern itself with returning keys (same for any other method that only returns values in arrays)."]},{"l":"Obsolete things I've deleted","p":["These were already planned, and indicated as deprecated for a while now, but they've now been removed:","enmap.equals()(extremely expensive, not useful)","enmap.exists()(use has(key, prop))","enmap.setProp()(use set(key, prop))","enmap.pushIn()(use push(key, prop))","enmap.getProp()(use get(key, prop))","enmap.deleteProp()(use delete(key, prop))","enmap.removeProp()(use remove(key, prop))","enmap.hasProp()(use has(key, prop))","enmap.ready or enmap.defer and all that jazz - completely useless in this sync world."]},{"l":"Misc changes","p":["The use of '::memory:: as a name is removed, you can use inMemory: true instead. That means new Enmap('::memory::') is now new Enmap({ inMemory: true }).","In all loop methods like every, some, map and filter, the value now comes first, and key second. This matches array methods closer.","Methods will no longer return the enmap upon executing an action. It's always felt weird to me that some methods returned the enmap and others returned data.","The destroy method is removed, since it doesn't make much sense to delete all the db tables. You can still delete all your stuff with clear() though.","wal and verbose options have been removed from options, I honestly prefer the default to journal_mode=WAL. If you don't like it, run enmap.db.pragma('journal_mode=DELETE')(you can run direct DB calls to sqlite3 this way). For verbose, pass it as options.sqliteOptions, like, new Enmap({ name: 'blah', sqliteOptions: { verbose: true }})."]}],[{"l":"Usage Documentation","p":["Mostly, this documentation will be concentrating on the \"persistent\" version of enmap - the one where data is saved automatically.","If you don't want persistence, the only difference is how you initialize the enmap:"]},{"l":"Persistent Enmaps","p":["By default, Enmap saves only in memory and does not save anything to disk. To have persistent storage, you need to add some options. Enmaps with a \"name\" option will save, and there are additional options you can use to fine-tune the saving and loading features."]},{"l":"Enmap Options","p":["The following is a list of all options that are available in Enmap, when initializing it:","name: A name for the enmap. Defines the table name in SQLite (the name is \"cleansed\" before use).","inMemory: Defaults to false. If set to true, no data is saved to disk. Methods will work the same but restarting your app will lose all data. This can be set separately in each enmap.","dataDir: Defaults to ./data. Determines where the sqlite files will be stored. Can be relative (to your project root) or absolute on the disk. Windows users , remember to escape your backslashes!","ensureProps: Defaults to true. When adding values to an object using a path, ensureProps will automatically create any level of object necessary for the value to be written.","autoEnsure: default is disabled. When provided a value, essentially runs ensure(key, autoEnsure) automatically so you don't have to. This is especially useful on get(), but will also apply on set(), and any array and object methods that interact with the database.","serializer Optional. If a function is provided, it will execute on the data when it is written to the database. This is generally used to convert the value into a format that can be saved in the database, such as converting a complete class instance to just its ID. This function may return the value to be saved, or a promise that resolves to that value (in other words, can be an async function).","deserializer Optional. If a function is provided, it will execute on the data when it is read from the database. This is generally used to convert the value from a stored ID into a more complex object. This function may return a value, or a promise that resolves to that value (in other words, can be an async function).","sqliteOptions Optional. An object of options to pass to the better-sqlite3 Database constructor."]}],[{"l":"Basic Data Use","p":["Now that we have a functional Enmap structure (which we'll always refer to as myEnmap), we're ready to start writing data to it, and getting data from it.","The code samples on this page assume that you have correctly initialized myEnmap"]},{"l":"Writing Data","p":["In terms of Enmap, \"writing\", \"adding\" and \"editing\" data is essentially the same thing. When using the basic set() method, if the key does not exist it's created, and if it does, it's modified.","Enmap supports pretty much all native JavaScript data types. However, it cannot support Class Instances directly. That means if you have, say, a \"User\" object or a \"House\" class, they cannot be stored here.","There is however a workaround, which is to use Serializing and Deserializing.","Objects and Arrays are a little more complex to deal with, so they have their own page. See Working with Objects for more information.","The usage for the set() method is simple:","key must be a string or integer. A key should be unique, otherwise it will be overwritten by new values using the same key.","value must be a supported native data type as mentioned above.","Here are a few examples of writing simple data values:"]},{"l":"Retrieving Data","p":["Getting data back from an Enmap is just as simple as writing to it. All you need is the key of what you want to retrieve, and you get its value back!","That's pretty much it for only retrieving a single data value. There are more complex operations that are available, take a look at Array Methods for the more advanced things you can do on Enmap's data!"]},{"l":"Deleting Data","p":["Removing data from Enmap is as simple as saving or retrieving. You can easily use the delete() method as such:"]}],[{"i":"#","p":["What is Paths in Enmap, how to use them, what is their syntax?"]},{"l":"Understanding Paths","p":["In a whole lot of methods for Enmap, one of the properties is the \"path\". Paths are used in Object data saved in Enmap, that is to say, setting or ensuring a value that is an object at the top level.","To understand what a path really means, we can start by having an object as a value. Here I'm not even using Enmap, as the idea is related to basic JavaScript, not my module.","So here we have an object that actually has multiple levels, that is to say, the c and sub properties have, as a value, another object with its own keys. sub takes this further with 4 different levels, just to fully demonstrate my point.","So how would we reach the values in this object? Well, in core JavaScript, let's say we wanted to get the word \"cool\", we'd use myObject.sub.values.are.cool. This is one way to access object properties, the other one being myObject[sub][values][are][cool](where those strings can be variables, btw, for dynamic property access).","Alright so what about the array, there? Well, arrays are accessed through their index, meaning their position in the array, starting at 0. That means to access the c.and values, you'd do something like myObject.c.and[0]. That looks like a strange syntax I'll admit, but considering you can use the same for objects, myObject[c][and][1] perhaps looks a bit more coherent."]},{"l":"Doing it in Enmap","p":["Now that you've seen how to access those properties in regular JavaScript, what about doing it in Enmap? Well, it's actually quite simple: the path parameter in the methods simply take exactly what you've seen above, with 2 exceptions:","The path doesn't include the object name (which is your key)","You don't need to use variables for dynamic paths since it's a string","What does that mean in reality? Well let's rewrite the example above as Enmap code:","To access the \"cool\" string, the code then becomes myEnmap.get(myObject, sub.values.are). Accessing the array values looks the same: myEnmap.get(myObject, c.and[0]). In this case indexes can be used either way, so you can also do myEnmap.get(myObject, c.and.0) and that'll work equally well."]}],[{"l":"Working with Objects","p":["Enmap is a great way to store structured data, and offers a few helper features that directly affect both objects and arrays.","Let's assume for a moment that we want to store the following data structure in Enmap:","This structure has 5 \"properties\": first, second, changeme, isCool, sub. The sub property has 2 properties of its own, yay and thing.","To store this structure in Enmap, you can use a variable, or just straight-up write the object:","Note: All further methods require the value to be an object. If you attempt to get, set, modify or remove using the below methods and your value isn't an object, Enmap will throw an error."]},{"l":"Getting properties","p":["Retrieving a specific property from an object is done through the get() method, by specifying both the key and the \"path\" to the property you want.","The exact method is Enmap.get(key, path)."]},{"l":"Checking if a property exists","p":["You can also check if a specific property exists or not. This is done through the has method, with a key, and path to the property:"]},{"l":"Modifying Properties","p":["There are a few various ways to modify properties of both Objects and Arrays. The very basic way to set a property on an object or array is through .set(key, value, path) like the following examples:","As you can see, setProp() and getProp() work on the same concept that the path can be as complex as you want.","Arrays have additional helper methods, you can see them here."]}],[{"l":"Array Methods","p":["While Enmap is a Map enhanced with Array methods, Enmap also offers some enhanced array methods for the data stored inside of it. Talk about Arrayception!","So what do I mean by methods for your stored data? I mean that you can store arrays inside Enmap, and directly push, pull, add and remove from those arrays. There are methods to work both on direct arrays, as well as arrays stored inside of an object.","Let's take a look at three example entries in Enmap that we can use. The first is a direct array, the second is an array inside an object, the last is an array of objects."]},{"l":"Adding to the array","p":["There are two methods to push to an array, one for simple arrays and one for arrays inside objects. Pushing in an Enmap array is the same as a regular array push: it adds the element to the end of the array.","The third parameter in push is the \"path\" to the array in an object. It works the same as the properties path used in Working With Objects."]},{"l":"Removing from the array","p":["Similarly, you can remove from an array. With the normal path system, you can either remove via the index in the array, or remove simple strings. To remove a complex object, you'll need to use a function in the remove method."]}],[{"l":"Mathematical Methods","p":["This page is a work in progress and may not have the polish of a usual Evie-Written document!","Some quick docs:"]},{"l":"enmap.math(key, operation, operator, [objectPath])","p":["Possible Operators (accepts all variations listed below, as strings):","+, add, addition: Increments the value in the enmap by the provided value.","-, sub, subtract: Decrements the value in the enmap by the provided value.","*, mult, multiply: Multiply the value in the enmap by the provided value.","/, div, divide: Divide the value in the enmap by the provided value.","%, mod, modulo: Gets the modulo of the value in the enmap by the provided value.","^, exp, exponential: Raises the value in the enmap by the power of the provided value."]},{"l":"enmap.inc(key, [objectPath])"},{"l":"enmap.dec(key. [objectPath])"}],[{"i":"#","p":["This page will describe how to use Enmap from multiple files within your same project. Note that I mean the same app, process, or shard, but different files within this one running process."]},{"l":"Using from multiple files"},{"l":"A common issue","p":["When Enmap is used with its default options, it loads everything in its cache and generally provides your data from this cache, not directly from the database. In the case where you want to use the data from one Enmap from multiple locations, you might encounter the following issue:","Hi! When I update data in Enmap from one file, it doesn't update in the other file, I have to restart the bot to update. Is this a bug?","To answer my own obvious question: it's not a bug, it's a feature that I cannot implement. The way Enmap's cache works is that the data is loaded in memory _ in that __instance _ of Enmap, and only for that instance. This is what enables you to have many different Enmaps in your project - one Enmap doesn't share data with another.","However, this also means that when you do new Enmap({ name: something }) from more than one file, that's also a different instance, that doesn't share the same memory space. So not only will it not update the data in memory for the other file, it also uses double the memory. And of course, that's bad. So how do we fix this?"]},{"l":"The Shared Variable Method","p":["Admittedly, the vast majority of you Enmap users are doing Discord.js Bots, and even though Enmap works fine with any nodejs project that need simple data storage, bots are my main clients. Considering this fact, we have an extremely simple way to share an Enmap between multiple files: We attach it to the bot client. Usually your client is defined in your main file (index.js, app.js, bot.js, whatever you named it), and every part of your bot has access to this client. We can attach Enmap directly to it, like so:","This will work even if you're using a command handler, framework, or whatever - as long as you have access to a client variable, you have access to your enmaps.","Important Note: Do NOT override Discord.js' existing collections! That means, client.users, client.guilds, etc. See all the properties and methods for the Discord.js client- none of these should be overridden.","In other frameworks and libraries, you might have something similar. For example with Express or Koa for http servers, you can sometimes attach the enmap to your request from the very top, in a middleware. If that's not possible, or if you find that to be complicated, you can use the next method."]},{"l":"The Module Method","p":["All things considered, modules are probably the recommended way to use your Enmap in multiple files within your project. Not only does it give you a single file to import, lets you define multiple Enmaps you can individually import, it also gives you the ability to add specific functions to do common actions you use throughout your project.","As covered in My JavaScript Guide, modules are fairly straightforward. This is how I have done an Enmap shared module before:","This means you can simply require that file elsewhere. Let's say we called that file db.js, here's how you'd use it:","And as I mentioned, as a bonus you now have the ability to create functions which you can export and use, to simplify your code and remove duplication. So, let's say I need to get all the tags for a specific guild, and my tags are built using an object as shown above. To get all those tags for a guild, you'd need filters, right? Like so:","now let's say you use this code a lot in your app, and you'd like to not have to type this whole thing every time. You could add a simple function in your module that only takes an ID and returns the tags:","And there you have it! There are other ways to build the exports, you can also split it differently, take a look at My Modules Guide for more information."]}],[{"i":"#","p":["Learn how to manipulate the data you save and retrieve from the database, to more easily store complex data without having to convert it to simple data everywhere you use it."]},{"l":"Serializing and Deserializing","p":["Introduced in Enmap 5.6, Serializers and Deserializers are functions that you use to manipulate the data before storing it in the database, or before using it after retrieving it.","This feature is born from a limitation in Enmap: it cannot store very complex objects, such as the instance of a class, objects with circular references, functions, etc. So, typically when you have such data, you need to manually convert it to some simple representation before storing, and then do the inverse after getting it from enmap. This is a more automated way of doing it."]},{"l":"What are they?","p":["The Serializer function runs every single time data is stored in the enmap, if one is provided. This function receives the data provided to set() as an input, and must return a value to be stored in the database. This function MUST be synchronous, that is to say, cannot be an async function or return a promise.","The Deserializer function is the reverse, and runs on each value pulled from the database, before it is returned through the get() method. This function receives the data stored in the database and returns the value that you want to use directly. This function MUST be synchronous, that is to say, cannot be an async function or return a promise."]},{"l":"Examples"},{"l":"Guild Settings: A more sensible example","p":["Taking a hit from my own example of Per-Server Settings, this is a better example that doesn't require storing just the name of a channel, but straight-up the channel itself."]}],[{"i":"#","p":["The complete and unadultered API documentation for every single method and property accessible in Enmap."]},{"l":"Full Documentation","p":["The following is the complete list of methods available in Enmap. As it is auto-generated from the source code and its comments, it's a little more \"raw\" than the Usage docs. However, it has the benefit of being more complete and usually more up to date than the manually written docs.","If you're doing a PR on the docs github, please do not manually edit the below contents, as it will be overwritten. Check the src/index.ts source code and change the comments there instead!"]},{"l":"Enmap Class","p":["The Enmap class provides a simple, synchronous, fast key/value storage built around better-sqlite3. Contains extra utility methods for managing arrays and objects."]},{"l":"Properties"},{"l":"Methods"},{"l":"size ⇒ number","p":["Get the number of key/value pairs saved in the enmap.","Kind: instance property of Enmap Returns: number- The number of elements in the enmap. Read only: true"]},{"l":"db ⇒ Database","p":["Get the better-sqlite3 database object. Useful if you want to directly query or interact with the underlying SQLite database. Use at your own risk, as errors here might cause loss of data or corruption!","Kind: instance property of Enmap"]},{"l":"autonum ⇒ string","p":["Generates an automatic numerical key for inserting a new value. This is a \"weak\" method, it ensures the value isn't duplicated, but does not guarantee it's sequential (if a value is deleted, another can take its place). Useful for logging, actions, items, etc - anything that doesn't already have a unique ID.","Kind: instance property of Enmap Returns: string- The generated key number. Read only: true Example"]},{"l":"set(key, value, path)","p":["Sets a value in Enmap. If the key already has a value, overwrites the data (or the value in a path, if provided).","Kind: instance method of Enmap","Param","Description","key","Required. The location in which the data should be saved.","value","Required. The value to write. Values must be serializable, which is done through (better-serialize)[https://github.com/RealShadowNova/better-serialize] If the value is not directly serializable, please use a custom serializer/deserializer.","path","Optional. The path to the property to modify inside the value object or array. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\"","Example"]},{"l":"get(key, path) ⇒","p":["Retrieves a value from the enmap, using its key.","Kind: instance method of Enmap Returns: The parsed value for this key.","Param","Description","key","The key to retrieve from the enmap.","path","Optional. The property to retrieve from the object or array. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\"","Example"]},{"l":"has(key) ⇒ boolean","p":["Returns whether or not the key exists in the Enmap.","Kind: instance method of Enmap","Param","Description","key","Required. The key of the element to add to The Enmap or array.","Example"]},{"l":"delete(key, path)","p":["Deletes a key in the Enmap.","Kind: instance method of Enmap","Param","Description","key","Required. The key of the element to delete from The Enmap.","path","Optional. The name of the property to remove from the object. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\""]},{"l":"clear() ⇒ void","p":["Deletes everything from the enmap.","Kind: instance method of Enmap"]},{"l":"keys() ⇒ Array.<string>","p":["Get all the keys of the enmap as an array.","Kind: instance method of Enmap Returns: Array.< string>- An array of all the keys in the enmap."]},{"l":"values() ⇒ Array.<*>","p":["Get all the values of the enmap as an array.","Kind: instance method of Enmap Returns: Array.<*>- An array of all the values in the enmap."]},{"l":"entries() ⇒ Array.<Array.<*, *>>","p":["Get all entries of the enmap as an array, with each item containing the key and value.","Kind: instance method of Enmap Returns: Array.< Array.<*, *>>- An array of arrays, with each sub-array containing two items, the key and the value."]},{"l":"update(key, valueOrFunction) ⇒ *","p":["Update an existing object value in Enmap by merging new keys. This only works on objects, any other value will throw an error. Heavily inspired by setState from React's class components. This is very useful if you have many different values to update and don't want to have more than one .set(key, value, prop) lines.","Kind: instance method of Enmap Returns: *- The modified (merged) value.","Param","Type","Description","key","string","The key of the object to update.","valueOrFunction","*","Either an object to merge with the existing value, or a function that provides the existing object and expects a new object as a return value. In the case of a straight value, the merge is recursive and will add any missing level. If using a function, it is your responsibility to merge the objects together correctly.","Example"]},{"l":"observe(key, path) ⇒ *","p":["Returns an observable object. Modifying this object or any of its properties/indexes/children will automatically save those changes into enmap. This only works on objects and arrays, not \"basic\" values like strings or integers.","Kind: instance method of Enmap Returns: *- The value for this key.","Param","Type","Description","key","*","The key to retrieve from the enmap.","path","string","Optional. The property to retrieve from the object or array."]},{"l":"push(key, value, path, allowDupes)","p":["*","allowDupes","boolean","Default","Description","Example","false","key","Kind: instance method of Enmap","Optional. Allow duplicate values in the array (default: false).","Optional. The path to the property to modify inside the value object or array. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\"","Param","path","Push to an array value in Enmap.","Required. The key of the array element to push to in Enmap.","Required. The value to push to the array.","string","Type","value"]},{"l":"math(key, operation, operand, path) ⇒ number","p":["Description","Example","Executes a mathematical operation on a value and saves it in the enmap.","key","Kind: instance method of Enmap Returns: number- The updated value after the operation","number","operand","operation","Optional. The property path to execute the operation on, if the value is an object or array.","Param","path","string","The enmap key on which to execute the math operation.","The right operand of the operation.","Type","Which mathematical operation to execute. Supports most math ops: =, -, *, /, %, ^, and english spelling of those operations."]},{"l":"inc(key, path) ⇒ number","p":["Increments a key's value or property by 1. Value must be a number, or a path to a number.","Kind: instance method of Enmap Returns: number- The udpated value after incrementing.","Param","Type","Description","key","string","The enmap key where the value to increment is stored.","path","Optional. The property path to increment, if the value is an object or array.","Example"]},{"l":"dec(key, path) ⇒ Enmap","p":["Decrements a key's value or property by 1. Value must be a number, or a path to a number.","Kind: instance method of Enmap Returns: Enmap- The enmap.","Param","Type","Description","key","string","The enmap key where the value to decrement is stored.","path","Optional. The property path to decrement, if the value is an object or array.","Example"]},{"l":"ensure(key, defaultValue, path) ⇒ *","p":["Returns the key's value, or the default given, ensuring that the data is there. This is a shortcut to \"if enmap doesn't have key, set it, then get it\" which is a very common pattern.","Kind: instance method of Enmap Returns: *- The value from the database for the key, or the default value provided for a new key.","Param","Type","Description","key","string","Required. The key you want to make sure exists.","defaultValue","*","Required. The value you want to save in the database and return as default.","path","Optional. If presents, ensures both the key exists as an object, and the full path exists. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\"","Example"]},{"l":"includes(key, value, path) ⇒ boolean","p":["Performs Array.includes() on a certain enmap value. Works similar to Array.includes().","Kind: instance method of Enmap Returns: boolean- Whether the array contains the value.","Param","Type","Description","key","string","Required. The key of the array to check the value of.","value","string| number","Required. The value to check whether it's in the array.","path","Optional. The property to access the array inside the value object or array. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\""]},{"l":"remove(key, val, path)","p":["Remove a value in an Array or Object element in Enmap. Note that this only works for values, not keys. Note that only one value is removed, no more. Arrays of objects must use a function to remove, as full object matching is not supported.","Kind: instance method of Enmap","Param","Type","Description","key","string","Required. The key of the element to remove from in Enmap.","val","*| function","Required. The value to remove from the array or object. OR a function to match an object. If using a function, the function provides the object value and must return a boolean that's true for the object you want to remove.","path","Optional. The name of the array property to remove from. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\". If not presents, removes directly from the value.","Example"]},{"l":"export() ⇒ string","p":["Exports the enmap data to stringified JSON format. WARNING: Does not work on memory enmaps containing complex data!","Kind: instance method of Enmap Returns: string- The enmap data in a stringified JSON format."]},{"l":"import(data, overwrite, clear)","p":["boolean","clear","data","Default","Defaults to false. Whether to clear the enmap of all data before importing ( WARNING: Any existing data will be lost! This cannot be undone.)","Defaults to true. Whether to overwrite existing key/value data with incoming imported data","Description","false","Import an existing json export from enmap. This data must have been exported from enmap, and must be from a version that's equivalent or lower than where you're importing it.(This means Enmap 5 data is compatible in Enmap 6).","Kind: instance method of Enmap","overwrite","Param","string","The data to import to Enmap. Must contain all the required fields provided by an enmap export().","true","Type"]},{"l":"multi(names, options) ⇒ Object","p":["Initialize multiple Enmaps easily.","Kind: instance method of Enmap Returns: Object- An array of initialized Enmaps.","Param","Type","Description","names","Array.< string>","Array of strings. Each array entry will create a separate enmap with that name.","options","Object","Options object to pass to each enmap, excluding the name..","Example"]},{"l":"random([count]) ⇒ * | Array.<*>","p":["Obtains random value(s) from this Enmap. This relies on Enmap#array.","Kind: instance method of Enmap Returns: *| Array.<*>- The single value if count is undefined, or an array of values of count length","Param","Type","Default","Description","[count]","number","1","Number of values to obtain randomly"]},{"l":"randomKey([count]) ⇒ * | Array.<*>","p":["Obtains random key(s) from this Enmap. This relies on Enmap#keyArray","Kind: instance method of Enmap Returns: *| Array.<*>- The single key if count is undefined, or an array of keys of count length","Param","Type","Default","Description","[count]","number","1","Number of keys to obtain randomly"]},{"l":"every(valueOrFunction, [path]) ⇒ boolean","p":["Similar to Array.every(). Supports either a predicate function or a value to compare. Returns true only if the predicate function returns true for all elements in the array (or the value is strictly equal in all elements).","Kind: instance method of Enmap","Param","Type","Description","valueOrFunction","function| string","Function used to test (should return a boolean), or a value to compare.","[path]","string","Required if the value is an object. The path to the property to compare with."]},{"l":"some(valueOrFunction, [path]) ⇒ Array","p":["Similar to Array.some(). Supports either a predicate function or a value to compare. Returns true if the predicate function returns true for at least one element in the array (or the value is equal in at least one element).","Kind: instance method of Enmap","Param","Type","Description","valueOrFunction","function| string","Function used to test (should return a boolean), or a value to compare.","[path]","string","Required if the value is an object. The path to the property to compare with."]},{"l":"map(pathOrFn) ⇒ Array","p":["Similar to Array.map(). Returns an array of the results of applying the callback to all elements.","Kind: instance method of Enmap","Param","Type","Description","pathOrFn","function| string","A function that produces an element of the new Array, or a path to the property to map."]},{"l":"find(pathOrFn, [value]) ⇒ *","p":["Searches for a single item where its specified property's value is identical to the given value( item[prop] === value), or the given function returns a truthy value. In the latter case, this is similar to Array.find().","Kind: instance method of Enmap","Param","Type","Description","pathOrFn","string| function","The path to the value to test against, or the function to test with","[value]","*","The expected value - only applicable and required if using a property for the first argument","Example"]},{"l":"findIndex(pathOrFn, [value]) ⇒ string | number","p":["Searches for the key of a single item where its specified property's value is identical to the given value( item[prop] === value), or the given function returns a truthy value. In the latter case, this is similar to Array.findIndex().","Kind: instance method of Enmap","Param","Type","Description","pathOrFn","string| function","The path to the value to test against, or the function to test with","[value]","*","The expected value - only applicable and required if using a property for the first argument","Example"]},{"l":"reduce(predicate, [initialValue]) ⇒ *","p":["Similar to Array.reduce().","Kind: instance method of Enmap","Param","Type","Description","predicate","function","Function used to reduce, taking three arguments; accumulator, currentValue, currentKey.","[initialValue]","*","Starting value for the accumulator"]},{"l":"filter(pathOrFn, [value]) ⇒ Enmap","p":["Similar to Array.filter(). Returns an array of values where the given function returns true for that value. Alternatively you can provide a value and path to filter by using exact value matching.","Kind: instance method of Enmap","Param","Type","Description","pathOrFn","function","The path to the value to test against, or the function to test with. If using a function, this function should return a boolean.","[value]","string","Value to use as this when executing function"]},{"l":"sweep(pathOrFn, [value]) ⇒ number","p":["Deletes entries that satisfy the provided filter function or value matching.","Kind: instance method of Enmap Returns: number- The number of removed entries.","Param","Type","Description","pathOrFn","function| string","The path to the value to test against, or the function to test with.","[value]","*","The expected value - only applicable and required if using a property for the first argument."]},{"l":"changed(cb)","p":["Function called whenever data changes within Enmap after the initial load. Can be used to detect if another part of your code changed a value in enmap and react on it.","Kind: instance method of Enmap","Param","Type","Description","cb","function","A callback function that will be called whenever data changes in the enmap.","Example"]},{"l":"partition(pathOrFn, value) ⇒ Array.<Array.<*>>","p":["Separates the Enmap into multiple arrays given a function that separates them.","Kind: instance method of Enmap Returns: Array.< Array.<*>>- An array of arrays with the partitioned data.","Param","Type","Description","pathOrFn","*","the path to the value to test against, or the function to test with.","value","the value to use as a condition for partitioning."]}],[{"l":"API Reference","p":["Complete TypeScript API documentation for Enmap with full type information.","This documentation is automatically generated from the TypeScript source code and includes complete type signatures, generics, and cross-references."]},{"l":"Quick Navigation"},{"l":"Core Classes","p":["Enmap Class- Main database class with all methods"]},{"l":"Interfaces","p":["EnmapOptions- Configuration options for Enmap"]},{"l":"Key Features"},{"l":"TypeScript Support","p":["Full type safety with generics EnmapV, SV","Custom types like PathT for nested object access","Precise return types and parameter validation"]},{"l":"Method Categories"},{"l":"Core Operations","p":["set(), get(), has(), delete(), clear()","Type-safe with optional path parameters"]},{"l":"Array Operations","p":["push(), includes(), remove()","Full array method equivalents: map(), filter(), find(), etc."]},{"l":"Mathematical Operations","p":["math(), inc(), dec()","Type-constrained to numeric values"]},{"l":"Advanced Features","p":["observe()- Reactive objects that auto-save","ensure()- Type-safe default value assignment","update()- React-style object merging","The TypeScript API documentation includes live examples, full method signatures, and links to source code for every feature."]}],[{"i":"#","p":["Enmap API Reference v6.1.3","Enmap API Reference/ EnmapOptions"]},{"l":"EnmapOptions (V, SV)","p":["Defined in: index.ts:29"]},{"l":"Type Parameters","p":["Type Parameter","Default type","V","unknown","SV"]},{"l":"Properties","p":["( value, key) => SV","( value, key) => V","autoEnsure?","boolean","dataDir?","Defined in","deserializer?","ensureProps?","index.ts:30","index.ts:31","index.ts:32","index.ts:33","index.ts:34","index.ts:35","index.ts:36","index.ts:37","inMemory?","name?","Options","Property","serializer?","sqliteOptions?","string","Type","V"]}],[{"i":"#","p":["Enmap API Reference v6.1.3","Enmap API Reference/ default"]},{"l":"default (V, SV)","p":["Defined in: index.ts:77","A simple, synchronous, fast key/value storage build around better-sqlite3. Contains extra utility methods for managing arrays and objects."]},{"l":"Type Parameters","p":["Type Parameter","Default type","V","any","SV","unknown"]},{"l":"Constructors"},{"l":"Constructor","p":["Defined in: index.ts:109","Initializes a new Enmap, with options."]},{"l":"Parameters","p":["Parameter","Type","Description","options","EnmapOptions< V, SV>","Options for the enmap. See https://enmap.alterion.dev/usage#enmap-options for details."]},{"l":"Returns","p":["Enmap< V, SV>"]},{"l":"Example"},{"l":"Accessors"},{"l":"size"},{"l":"Get Signature","p":["Defined in: index.ts:292","Get the number of key/value pairs saved in the enmap."]},{"i":"returns-1","l":"Returns","p":["number","The number of elements in the enmap."]},{"l":"count"},{"i":"get-signature-1","l":"Get Signature","p":["Defined in: index.ts:300"]},{"i":"returns-2","l":"Returns","p":["number"]},{"l":"length"},{"i":"get-signature-2","l":"Get Signature","p":["Defined in: index.ts:304"]},{"i":"returns-3","l":"Returns","p":["number"]},{"l":"db"},{"i":"get-signature-3","l":"Get Signature","p":["Defined in: index.ts:313","Get the better-sqlite3 database object. Useful if you want to directly query or interact with the underlying SQLite database. Use at your own risk, as errors here might cause loss of data or corruption!"]},{"i":"returns-4","l":"Returns","p":["Database"]},{"l":"autonum"},{"i":"get-signature-4","l":"Get Signature","p":["Defined in: index.ts:327","Generates an automatic numerical key for inserting a new value. This is a \"weak\" method, it ensures the value isn't duplicated, but does not guarantee it's sequential (if a value is deleted, another can take its place). Useful for logging, actions, items, etc - anything that doesn't already have a unique ID."]},{"i":"example-1","l":"Example"},{"i":"returns-5","l":"Returns","p":["string","The generated key number."]},{"l":"Methods"},{"l":"set()","p":["Defined in: index.ts:195","Sets a value in Enmap. If the key already has a value, overwrites the data (or the value in a path, if provided)."]},{"i":"parameters-1","l":"Parameters","p":["Parameter","Type","Description","key","string","Required. The location in which the data should be saved.","value","any","Required. The value to write. Values must be serializable, which is done through (better-serialize)[https://github.com/RealShadowNova/better-serialize] If the value is not directly serializable, please use a custom serializer/deserializer.","path?","Path< V, keyof V>","Optional. The path to the property to modify inside the value object or array. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\""]},{"i":"returns-6","l":"Returns","p":["this"]},{"i":"example-2","l":"Example"},{"l":"get()","p":["Defined in: index.ts:221","Retrieves a value from the enmap, using its key."]},{"i":"parameters-2","l":"Parameters","p":["Parameter","Type","Description","key","string","The key to retrieve from the enmap.","path?","Path< V, keyof V>","Optional. The property to retrieve from the object or array. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\""]},{"i":"returns-7","l":"Returns","p":["any","The parsed value for this key."]},{"i":"example-3","l":"Example"},{"l":"has()","p":["Defined in: index.ts:250","Returns whether or not the key exists in the Enmap."]},{"i":"parameters-3","l":"Parameters","p":["Parameter","Type","Description","key","string","Required. The key of the element to add to The Enmap or array."]},{"i":"returns-8","l":"Returns","p":["boolean"]},{"i":"example-4","l":"Example"},{"l":"delete()","p":["Defined in: index.ts:263","Deletes a key in the Enmap."]},{"i":"parameters-4","l":"Parameters","p":["Parameter","Type","Description","key","string","Required. The key of the element to delete from The Enmap.","path?","Path< V, keyof V>","Optional. The name of the property to remove from the object. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\""]},{"i":"returns-9","l":"Returns","p":["this"]},{"l":"clear()","p":["Defined in: index.ts:282","Deletes everything from the enmap."]},{"i":"returns-10","l":"Returns","p":["void"]},{"l":"keys()","p":["Defined in: index.ts:348","Get all the keys of the enmap as an array."]},{"i":"returns-11","l":"Returns","p":["string[]","An array of all the keys in the enmap."]},{"l":"indexes()","p":["Defined in: index.ts:357"]},{"i":"returns-12","l":"Returns","p":["string[]"]},{"l":"values()","p":["Defined in: index.ts:365","Get all the values of the enmap as an array."]},{"i":"returns-13","l":"Returns","p":["V[]","An array of all the values in the enmap."]},{"l":"entries()","p":["Defined in: index.ts:378","Get all entries of the enmap as an array, with each item containing the key and value."]},{"i":"returns-14","l":"Returns","p":["[string, V][]","An array of arrays, with each sub-array containing two items, the key and the value."]},{"l":"update()","p":["Defined in: index.ts:413","Update an existing object value in Enmap by merging new keys. This only works on objects, any other value will throw an error. Heavily inspired by setState from React's class components. This is very useful if you have many different values to update and don't want to have more than one .set(key, value, prop) lines."]},{"i":"parameters-5","l":"Parameters","p":["Parameter","Type","Description","key","string","The key of the object to update.","valueOrFunction","Partial< V> | ( data) => V","Either an object to merge with the existing value, or a function that provides the existing object and expects a new object as a return value. In the case of a straight value, the merge is recursive and will add any missing level. If using a function, it is your responsibility to merge the objects together correctly."]},{"i":"returns-15","l":"Returns","p":["V","The modified (merged) value."]},{"i":"example-5","l":"Example"},{"l":"observe()","p":["Defined in: index.ts:433","Returns an observable object. Modifying this object or any of its properties/indexes/children will automatically save those changes into enmap. This only works on objects and arrays, not \"basic\" values like strings or integers."]},{"i":"parameters-6","l":"Parameters","p":["Parameter","Type","Description","key","string","The key to retrieve from the enmap.","path?","Path< V, keyof V>","Optional. The property to retrieve from the object or array."]},{"i":"returns-16","l":"Returns","p":["any","The value for this key."]},{"l":"push()","p":["Defined in: index.ts:457","Push to an array value in Enmap."]},{"i":"parameters-7","l":"Parameters","p":["allowDupes?","boolean","Default value","Description","false","key","Optional. Allow duplicate values in the array (default: false).","Optional. The path to the property to modify inside the value object or array. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\"","Parameter","path?","Path< V, keyof V>","Required. The key of the array element to push to in Enmap.","Required. The value to push to the array.","string","Type","undefined","V","value"]},{"i":"returns-17","l":"Returns","p":["this"]},{"i":"example-6","l":"Example"},{"l":"math()","p":["Defined in: index.ts:487","Executes a mathematical operation on a value and saves it in the enmap."]},{"i":"parameters-8","l":"Parameters","p":["Parameter","Type","Description","key","string","The enmap key on which to execute the math operation.","operation","MathOps","Which mathematical operation to execute. Supports most math ops: =, -, *, /, %, ^, and english spelling of those operations.","operand","number","The right operand of the operation.","path?","Path< V, keyof V>","Optional. The property path to execute the operation on, if the value is an object or array."]},{"i":"returns-18","l":"Returns","p":["null| number","The updated value after the operation"]},{"i":"example-7","l":"Example"},{"l":"inc()","p":["Defined in: index.ts:512","Increments a key's value or property by 1. Value must be a number, or a path to a number."]},{"i":"parameters-9","l":"Parameters","p":["Parameter","Type","Description","key","string","The enmap key where the value to increment is stored.","path?","Path< V, keyof V>","Optional. The property path to increment, if the value is an object or array."]},{"i":"returns-19","l":"Returns","p":["this","The udpated value after incrementing."]},{"i":"example-8","l":"Example"},{"l":"dec()","p":["Defined in: index.ts:533","Decrements a key's value or property by 1. Value must be a number, or a path to a number."]},{"i":"parameters-10","l":"Parameters","p":["Parameter","Type","Description","key","string","The enmap key where the value to decrement is stored.","path?","Path< V, keyof V>","Optional. The property path to decrement, if the value is an object or array."]},{"i":"returns-20","l":"Returns","p":["this","The enmap."]},{"i":"example-9","l":"Example"},{"l":"ensure()","p":["Defined in: index.ts:559","Returns the key's value, or the default given, ensuring that the data is there. This is a shortcut to \"if enmap doesn't have key, set it, then get it\" which is a very common pattern."]},{"i":"parameters-11","l":"Parameters","p":["Parameter","Type","Description","key","string","Required. The key you want to make sure exists.","defaultValue","any","Required. The value you want to save in the database and return as default.","path?","Path< V, keyof V>","Optional. If presents, ensures both the key exists as an object, and the full path exists. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\""]},{"i":"returns-21","l":"Returns","p":["any","The value from the database for the key, or the default value provided for a new key."]},{"i":"example-10","l":"Example"},{"l":"includes()","p":["Defined in: index.ts:607","Performs Array.includes() on a certain enmap value. Works similar to Array.includes()."]},{"i":"parameters-12","l":"Parameters","p":["Parameter","Type","Description","key","string","Required. The key of the array to check the value of.","value","V","Required. The value to check whether it's in the array.","path?","Path< V, keyof V>","Optional. The property to access the array inside the value object or array. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\""]},{"i":"returns-22","l":"Returns","p":["boolean","Whether the array contains the value."]},{"l":"remove()","p":["Defined in: index.ts:632","Remove a value in an Array or Object element in Enmap. Note that this only works for values, not keys. Note that only one value is removed, no more. Arrays of objects must use a function to remove, as full object matching is not supported."]},{"i":"parameters-13","l":"Parameters","p":["Parameter","Type","Description","key","string","Required. The key of the element to remove from in Enmap.","val","V| ( value) => boolean","Required. The value to remove from the array or object. OR a function to match an object. If using a function, the function provides the object value and must return a boolean that's true for the object you want to remove.","path?","Path< V, keyof V>","Optional. The name of the array property to remove from. Should be a path with dot notation, such as \"prop1.subprop2.subprop3\". If not presents, removes directly from the value."]},{"i":"returns-23","l":"Returns","p":["this"]},{"i":"example-11","l":"Example"},{"l":"export()","p":["Defined in: index.ts:650","Exports the enmap data to stringified JSON format. WARNING: Does not work on memory enmaps containing complex data!"]},{"i":"returns-24","l":"Returns","p":["string","The enmap data in a stringified JSON format."]},{"l":"import()","p":["Defined in: index.ts:673","Import an existing json export from enmap. This data must have been exported from enmap, and must be from a version that's equivalent or lower than where you're importing it.(This means Enmap 5 data is compatible in Enmap 6)."]},{"i":"parameters-14","l":"Parameters","p":["Parameter","Type","Default value","Description","data","string","undefined","The data to import to Enmap. Must contain all the required fields provided by an enmap export().","overwrite","boolean","true","Defaults to true. Whether to overwrite existing key/value data with incoming imported data","clear","false","Defaults to false. Whether to clear the enmap of all data before importing ( WARNING: Any existing data will be lost! This cannot be undone.)"]},{"i":"returns-25","l":"Returns","p":["this"]},{"l":"multi()","p":["Defined in: index.ts:715","Initialize multiple Enmaps easily."]},{"i":"type-parameters-1","l":"Type Parameters","p":["Type Parameter","Default type","V","unknown","SV"]},{"i":"parameters-15","l":"Parameters","p":["Parameter","Type","Description","names","string[]","Array of strings. Each array entry will create a separate enmap with that name.","options?","Omit< EnmapOptions< V, SV>, name>","Options object to pass to each enmap, excluding the name.."]},{"i":"returns-26","l":"Returns","p":["Record< string, Enmap< V, SV>>","An array of initialized Enmaps."]},{"i":"example-12","l":"Example"},{"l":"random()","p":["Defined in: index.ts:738","Obtains random value(s) from this Enmap. This relies on Enmap#array."]},{"i":"parameters-16","l":"Parameters","p":["Parameter","Type","Default value","Description","count?","number","1","Number of values to obtain randomly"]},{"i":"returns-27","l":"Returns","p":["[string, V][]","The single value if count is undefined, or an array of values of count length"]},{"l":"randomKey()","p":["Defined in: index.ts:755","Obtains random key(s) from this Enmap. This relies on Enmap#keyArray"]},{"i":"parameters-17","l":"Parameters","p":["Parameter","Type","Default value","Description","count?","number","1","Number of keys to obtain randomly"]},{"i":"returns-28","l":"Returns","p":["string[]","The single key if count is undefined, or an array of keys of count length"]},{"l":"every()","p":["Defined in: index.ts:775","Similar to Array.every(). Supports either a predicate function or a value to compare. Returns true only if the predicate function returns true for all elements in the array (or the value is strictly equal in all elements)."]},{"i":"parameters-18","l":"Parameters","p":["Parameter","Type","Description","valueOrFunction","any","Function used to test (should return a boolean), or a value to compare.","path?","Path< V, keyof V>","Required if the value is an object. The path to the property to compare with."]},{"i":"returns-29","l":"Returns","p":["boolean"]},{"l":"some()","p":["Defined in: index.ts:802","Similar to Array.some(). Supports either a predicate function or a value to compare. Returns true if the predicate function returns true for at least one element in the array (or the value is equal in at least one element)."]},{"i":"parameters-19","l":"Parameters","p":["Parameter","Type","Description","valueOrFunction","any","Function used to test (should return a boolean), or a value to compare.","path?","Path< V, keyof V>","Required if the value is an object. The path to the property to compare with."]},{"i":"returns-30","l":"Returns","p":["boolean"]},{"l":"map()","p":["Defined in: index.ts:827","Similar to Array.map(). Returns an array of the results of applying the callback to all elements."]},{"i":"type-parameters-2","l":"Type Parameters","p":["Type Parameter","R"]},{"i":"parameters-20","l":"Parameters","p":["Parameter","Type","Description","pathOrFn","string| ( val, key) => R","A function that produces an element of the new Array, or a path to the property to map."]},{"i":"returns-31","l":"Returns","p":["R[]"]},{"l":"find()","p":["Defined in: index.ts:853","Searches for a single item where its specified property's value is identical to the given value( item[prop] === value), or the given function returns a truthy value. In the latter case, this is similar to Array.find()."]},{"i":"parameters-21","l":"Parameters","p":["Parameter","Type","Description","pathOrFn","string| ( val, key) => boolean","The path to the value to test against, or the function to test with","value?","any","The expected value - only applicable and required if using a property for the first argument"]},{"i":"returns-32","l":"Returns","p":["null| V"]},{"l":"Examples"},{"l":"findIndex()","p":["Defined in: index.ts:879","Searches for the key of a single item where its specified property's value is identical to the given value( item[prop] === value), or the given function returns a truthy value. In the latter case, this is similar to Array.findIndex()."]},{"i":"parameters-22","l":"Parameters","p":["Parameter","Type","Description","pathOrFn","string| ( val, key) => boolean","The path to the value to test against, or the function to test with","value?","any","The expected value - only applicable and required if using a property for the first argument"]},{"i":"returns-33","l":"Returns","p":["null| string"]},{"i":"examples-1","l":"Examples"},{"l":"reduce()","p":["Defined in: index.ts:900","Similar to Array.reduce()."]},{"i":"type-parameters-3","l":"Type Parameters","p":["Type Parameter","R"]},{"i":"parameters-23","l":"Parameters","p":["Parameter","Type","Description","predicate","( accumulator, val, key) => R","Function used to reduce, taking three arguments; accumulator, currentValue, currentKey.","initialValue?","R","Starting value for the accumulator"]},{"i":"returns-34","l":"Returns","p":["R"]},{"l":"filter()","p":["Defined in: index.ts:920","Similar to Array.filter(). Returns an array of values where the given function returns true for that value. Alternatively you can provide a value and path to filter by using exact value matching."]},{"i":"parameters-24","l":"Parameters","p":["Parameter","Type","Description","pathOrFn","string| ( val, key) => boolean","The path to the value to test against, or the function to test with. If using a function, this function should return a boolean.","value?","any","Value to use as this when executing function"]},{"i":"returns-35","l":"Returns","p":["V[]"]},{"l":"sweep()","p":["Defined in: index.ts:950","Deletes entries that satisfy the provided filter function or value matching."]},{"i":"parameters-25","l":"Parameters","p":["Parameter","Type","Description","pathOrFn","string| ( val, key) => boolean","The path to the value to test against, or the function to test with.","value?","any","The expected value - only applicable and required if using a property for the first argument."]},{"i":"returns-36","l":"Returns","p":["number","The number of removed entries."]},{"l":"changed()","p":["Defined in: index.ts:988","Function called whenever data changes within Enmap after the initial load. Can be used to detect if another part of your code changed a value in enmap and react on it."]},{"i":"parameters-26","l":"Parameters","p":["Parameter","Type","Description","cb","( key, oldValue, newValue) => void","A callback function that will be called whenever data changes in the enmap."]},{"i":"returns-37","l":"Returns","p":["void"]},{"i":"example-13","l":"Example"},{"l":"partition()","p":["Defined in: index.ts:998","Separates the Enmap into multiple arrays given a function that separates them."]},{"i":"parameters-27","l":"Parameters","p":["Parameter","Type","Description","pathOrFn","string| ( val, key) => boolean","the path to the value to test against, or the function to test with.","value?","any","the value to use as a condition for partitioning."]},{"i":"returns-38","l":"Returns","p":["[V[], V[]]","An array of arrays with the partitioned data."]}],[{"l":"Blog Posts"}],[{"l":"Enmap's History","p":["From the first moment where I started using the Discord.js library, one thing in it fascinated me: \"Collections\". Discord.js Collections are a Map structure from JavaScript on top of which a bunch of useful methods are added, most notably those from JavaScript's Array structure.","Things like map, filter, reduce, find, sort... they made Maps so useful, so much more powerful, that I admired their design. It struck me at one point, that if such a structure were to be separated from Discord.js and perhaps made to be saved in a database, it would make interacting with data so easy that even a child could do it.","So when I started getting seriously into bot that required their own data to be saved, I turned to Amish Shah (Hydrabolt) and I said to him, I said \"Listen, buddy, can I extract Collections and publish them as a separate module? That'd be awesome!\" and Amish replied, like the great guy he is, \"uhhhh sure, why not?\"","And so, in May 2017, the djs-collection module was born. It was a simple thing, just straight-up lifted from Discord.js' code (not illegally, mind you, I retained all proper licenses and credits to Hydrabolt!). The following month, I added persistence (saving to a database) to it and published djs-collection-persistent, which then became my own defacto way to save data to a database.","But... let's be honest, npm install --save djs-collection-persistent is a mouthful to type out. Plus, I was realizing that having those two as separate modules meant I had to update them separately and ensure they still worked individually... So at one point, I decided it was time to merge them.","Releasing a single repository meant that I could now change the name, because of the aformentioned \"omg mile-long name\" problem, and just the overall annoyance of writing it. So I settled on \"well, they're enhanced maps, let's call it Enmap!\". A quick search revealed Enmap's only other apparent meaning was that it was the name of a satellite, and I was guessing no one would confuse the two.","But I didn't want to force enmap users to have persistence, so at the same time I actually created a separate module called enmap-level, which controlled the database layer and was completely optional. These modules I called Providers since, obviously, they provided data persistence and and API.","Enmap 0.4.0 was released at the beginning of October 2017, and since then has grown into a fairly solid module used by tens of thousands of people across the world, not only in discord.js bots but also in other projects built with Node. Its solidity and simplicity makes it the ideal storage for simple key/value pairs, and I'm extremely proud to have made it.","At the moment of writing this (2018-09-02) Enmap has been downloaded over 32,000 times and is growing by the minute with almost 10,000 downloads in August alone!"]},{"l":"Update, August 2019","p":["It's been a year now since I last wrote this post. And in case you were wondering, growth hasn't stopped! In fact, it's quite accelerated. One big change that I made was to go back to a single locked-in database provider, which I describe in Why SQLite Only?","Other than that, and adding some new features due to the switch to better-sqlite3, the main event is that just las month I reached a whopping 500,000 downloads for Enmap. Yes, that's a half million downloads for my little useful module that I started making for myself and ended up being useful for so many."]}],[{"i":"#","p":["This page explains the reason behind the removal of the \"Provider\" system, and the selection of sqlite as the only database available for Enmap starting version 4"]},{"l":"Why SQLITE only?"},{"l":"Why providers in the first place?","p":["So one of the major changes from Enmap 3 to 4 is the removal of Providers. Providers were something I've had since Enmap 1.0 (when I converted from djs-collections-persistent), and had 2 advantages (2 reasons to have them in the first place).","It enabled supporting more databases, not only one. This gave more power to users, and, I thought, more capabilities.","It separated the memory enmap (non-persistent) from the database layer, so installing enmap didn't require installing sqlite."]},{"l":"And why remove them?","p":["But, after a year of updating Enmap, I realized that I'd painted myself in a corner with Providers. There came to light that there were multiple limitations to providers:","Features were limited to the \"lowest common denominator\", whatever was available to all providers. For instance, better-sqlite3 is a synchronous module that's nonblocking (which is a magical thing, really). But since all other providers required promises, then I had to use sqlite as a promise module.","Maintaining multiple providers is hard work. Every new feature would require updating all the providers (5 at this time), and there were many requests to create new providers which is an annoying, sometimes complicated task that adds even more work in the future.","There were features I wanted that simply weren't possible, physically, with the providers ( like the fetchAll/autoFetch options).","In addition, the advantages became lesser with time. I realized most people were using leveldb at first, then most switch to sqlite when I updated guides to use that provider. Essentially, most people use whatever they're told to use. So, just forcing one database wasn't that much of an issue and didn't affect the majority of users.","Also, most people did use enmap with persistence, and those that didn't... well, most users have enmap to use with discord.js bots in the first place which gives them Collection - almost the same as a non-persistent enmap."]},{"l":"What are the advantages of sqlite?","p":["The reasoning behind removing all other providers and keeping sqlite was for specific features and capabilities inherent to the module I'm using, better-sqlite3.","better-sqlite3 is, as I mention, synchronous, which means, no callbacks, no promises. Just straight-up \"make a request and it does it before the next line\". No more need for \"waiting\" for things, resolving promises, etc.","The sync nature of better-sqlite3 means I can add an autoFetch feature. I can simply say \"If the key isn't there, try to get the data\", without requiring the user to resolve a promise. This is awesome.","By the same token, I can also add simple things like \"get all keys in the database\" using a getter. This means you can do enmap.indexes and this is actually querying the database seamlessly without the user really knowing it does that. Same for enmap.count and other features I'm planning.","So overall, I'm happy with my decision. It gives me more power, it gives users more features, and the people affected by the removal of the other providers are few and far between. Hell, enmap-pgsql has less than 1000 downloads on npm which is mostly mirrors and caches. It showed me that provider was pretty useless in the first place."]},{"l":"But what about people that NEED a provider?","p":["I recognize that some people might want to use enmap and can't use sqlite. This is for many valid reasons, for example using it on heroku which doesn't support sqlite and leveldb. For those users, I'm keeping the providers open for maintenance. If someone wants to maintain and update the V3 branch, or even fork the entire system and maintain it under a new name, I have no issue with that (assuming licenses are properly kept). I'll accept PRs on all enmap repositories, including backporting some features and adding new ones.","I'm also keeping the V3 docs in this gitbook so it can be maintained through gitbook and PRed on github.","You can still install any provider as you would before, and install enmap using npm i eslachance/enmap#v3 for the version 3 branch that will remain.","Update: Enmap's no longer hosted on gitbook, and Enmap V3 is old enough to be dangerous to use due to potential security vulnerabilities, and providers most likely don't work on recent node versions anyways. All Enmap 3 providers are deprecated and archived."]}],[{"i":"#","p":["Why would Enmap V6 remove caching? Doesn't that make it slower? What gives?"]},{"l":"Why update to v6???","p":["So, you might be wondering what the main driver of Enmap Version 6 is. Let me give you a little bit of historical context here.","Before Enmap, there was djs-collection-persistent. This module was born from using discord.js' Collection, and the idea was, \"What if I could use that, but save it in a database?\" and thus, this whole adventure started. It saved data on leveldb, and it was alright. But who the hell wants to remember that name?","And thus, Enmap 1.0 was born. The Enhanced Map, which detached the name from djs itself. Enmap 1.0 already established Providers, including leveldb, postgresql, sqlite, rethinkdb, and mongo.","Enmap 2 and 3 added more features, moved things around, but generally stayed the same. Lot of bug fixes, added math, that sort of thing.","In Enmap 4, the main major change was that I removed all providers. I discovered (better-sqlite3)[https://www.npmjs.com/package/better-sqlite3], the first (and only?) synchronous database module. This started changing everything, but I didn't fully trust its performance yet. So Enmap 4 is sqlite only, persistent, but it still has its cache... that is to say, it's still an enhanced Map structure with persistence. Enmap 5 is more of the same, updates, small breaking changes, new features, etc.","But there's a problem : Enmap... is stil cached. It still uses a lot of memory, and that makes it slower than it should be. better-sqlite3 is fast and now I'm updating both the cache (Map) and the database! But I left this sleeping for the last few years as I was doing other things with life.","And here we are. Enmap 6.0 just removes caching, and updates all the map/array methods to directly interact with the database, no cache needed. This not only simplifies the code, and reduces RAM usage by a wide margin, it also makes Enmap much faster in a number of situations."]},{"l":"The SPEED"},{"l":"Loading","p":["Loading of data remains approximately the same when empty, but can be much faster in Enmap 6 the larger your database is, if autoFetch is true. With the 1 million rows, Enmap 6 loads in 6ms (milliseconds) but Enmap 5 loads in 20s (seconds). That's a massive difference, because of caching."]},{"l":"Adding Data","p":["This test inserts 1 million rows in a simple for loop. Each entry is an object with multiple randomly generated numbers.","Here's the actual test!","As you can see, the insert time is almost the same. I tried a few times, the time are around 2 minutes 50 seconds, +- 10 seconds. The speed does not change if the data already exists since it's all new data anyway (this means \"key creation\" doesn't cost anything)."]},{"l":"Looping over data","p":["Enmap, when looping over data, is generally faster.","Here's the tests and results. I tried more than once, and it's all the same ballpark."]},{"l":"Partition: Faster","p":["As you can see Enmap 6 is 8.5x faster with partitioning (again, this is on 1 million rows).","This is partially due to partition() returning an array of 2 Enmap structure. It would potentially be faster if Enmap 5's partition() returned arrays."]},{"l":"Filtering: Faster, sort of","p":["Filtering is also faster with Enmap 6 partially because Enmap 5 uses an Enmap as a return value, rather than an array. filterArray is definitely faster if the data is cached:"]},{"l":"Mapping: Slower","p":["I almost missed the difference in magnitude here: enmap.map() is slower by a lot. I'm not sure why and won't expend more time on this, and I don't feel guilty, because loading the 1M values took 17s for enmap5 versus the 6ms uncached enmap6. Still a clear value winner either way."]},{"l":"Conclusion","p":["I initially was very excited by the better Enmap 6 performance, but that was before I realized that some of this better performance is due to using memory-only Enmaps as return values. This means that some Enmap 5 methods are faster, such as filterArray and map.","As I really do want Enmap 6 to come out, however, I'm satisfied with the current removal of the cache. it still gives the advantage of having a lot less RAM usage since a cache isn't filled. It also means more consistency in query times, in memory usage, and availability - some cached methods like partition only worked with cached values and did not fetch keys before running.","I will, however, re-add caching to Enmap 6.1, as an optional addition and potentially more control over the caching, time-to-live, etc."]}],[{"i":"#","p":["Let's take a quick peek at what Josh is, and what it means for the future of Enmap"]},{"l":"Enmap and Josh","p":["As I've noted in my previous blog post, when Enmap moved to SQLite only, there were a few feathers and features lost in transition. Most notably, the loss of Providers was a big one, even though in my opinion it was a good trade-off to get the new features I wanted to include in Enmap 4 and onward.","But since that moment where Providers were removed, I had a plan in mind to give those that needed them an escape route. And not only that, Enmap itself does have some pretty solid limitations when it comes to growth, because of its lack of ability to support multiple processes and sharded applications."]},{"l":"Introducing Josh","p":["Then plan was Josh, all along. Josh is the Javascript Object Storage Helper, and if that sounds a lot like what Enmap does it's because it is. In fact, Josh could best be described to you, my reader, as \"A version of Enmap that doesn't have caching, is promised-based, and supports providers again\".","So I've been working on it for a few years now - not full time, mind you, as it would have been ready a long time ago, but as a side project. It's finally picked up steam, and you can Get Josh right now to try out the early access version. It's limited (not as powerful as Enmap is currently) but that's rapidly evolving."]},{"l":"So what does that mean for Enmap?","p":["You might immediately wonder, \"But Evie, if you're working on Josh, what's going to happen with Enmap?\" and I'm telling you right now, you don't need to worry about this. Enmap is still growing in popularity, I still have things to do with it, and I fully intend on maintaining and enhancing it in the future.","Josh might be similar to Enmap but it's not made to replace it! It has a different purpose, which is to support larger applications, potentially web-based ones, provide live updates, and all the things that were lost with Enmap's great provider purge. And since Josh is promise-based, it's not as simple to pick up as Enmap was, so I do expect people to start off with Enmap either way.","Josh and Enmap should, and will, be fully compatible with one another, in that you will be able to easily migrate between them (with export() and import() ), and moving from one to another would require a minimal amount of code changes. It's not zero, but I'm trying as much as possible to keep those differences as small as possible."]},{"l":"What does the future hold?","p":["I've already back-ported a few things that I originally intended for Josh as part of Enmap's new updates. The observe() method, as well as the serializer/deserializer feature, were originally intended for Josh but ended up being implementable in Enmap also. This means, if I add a feature to Josh, I will add it to Enmap if I can, if it's compatible. So you won't be left behind!","It is my sincere hope that Enmap and Josh will both continue to grow, to help more people, and to help us all create better code, together!"]}]]